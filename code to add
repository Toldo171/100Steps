https://medium.com/@aprofita_co/14-indie-game-marketing-tips-d8add7c3b5d4
https://webcache.googleusercontent.com/search?q=cache:F5Cje2_xM00J:https://gameanalytics.com/blog/marketing-indie-game-without-budget.html+&cd=18&hl=fr&ct=clnk&gl=fr&client=firefox-b-e
https://gamedevelopment.tutsplus.com/articles/marketing-your-indie-game-the-single-most-important-thing-to-learn--gamedev-7157


//------------------------------------------------------------
//Handles Slime Boss AI (activateSlimeBossAI)
//------------------------------------------------------------
//argument0 = NA

if (alarm[0] == 0)
{
	if (action_count == 0)
	{
		//Every 4 beats, we randomize initial direction and turn
		turn = choose(-1, 1);
		dir_indice = irandom_range(0,3);
		dir = dir_array[dir_indice];
	}
	
	if (action_count == 0 or action_count == 1)
	{
		moveCharacter(dir, self, step_length);
		dir_indice += turn;
		if (dir_indice == -1) {dir_indice = 3;}
		if (dir_indice == 4) {dir_indice = 0;}
		dir = dir_array[dir_indice];
		action_count += 1;
	}
	else if (action_count == 2)
	{
		shoot(directions.down, self, obj_Projectile_Ennemy, x, y + 3 * tile_height);
		shoot(directions.down, self, obj_Projectile_Ennemy, x + 1 * tile_height, y + 3 * tile_height);
		shoot(directions.down, self, obj_Projectile_Ennemy, x + 2 * tile_height, y + 3 * tile_height);
		shoot(directions.down, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 3 * tile_height);
		
		shoot(directions.up, self, obj_Projectile_Ennemy, x, y);
		shoot(directions.up, self, obj_Projectile_Ennemy, x + 1 * tile_height, y);
		shoot(directions.up, self, obj_Projectile_Ennemy, x + 2 * tile_height, y);
		shoot(directions.up, self, obj_Projectile_Ennemy, x + 3 * tile_height, y);
		
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y);
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y + 1 * tile_height);
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y + 2 * tile_height);
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y + 3 * tile_height);
		
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y);
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 1 * tile_height);
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 2 * tile_height);
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 3 * tile_height);
		
		action_count += 1;
	}
	else if (action_count == 3)
	{
		action_count = 0;
	}
}

//------------------------------------------------------------
//Check if ennemy is dead (checkDeadEnnemy)
//------------------------------------------------------------
//argument0 = NA

if (currentHearts <= 0)
{
	var x_grid_ennemy = (x div tile_width) * tile_width;
	var y_grid_ennemy = (y div tile_height) * tile_height;
	
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy, y_grid_ennemy, false);
	instance_destroy();
}

//------------------------------------------------------------
//Check if Boss is dead (checkDeadBoss)
//------------------------------------------------------------
//argument0 = NA

if (currentHearts <= 0)
{
	var x_grid_ennemy = (x div tile_width) * tile_width;
	var y_grid_ennemy = (y div tile_height) * tile_height;
	
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy, y_grid_ennemy, true);
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy + tile_width, y_grid_ennemy, true);
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy, y_grid_ennemy + tile_height, true);
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy + tile_width, y_grid_ennemy + tile_height, true);
	instance_destroy();
}
