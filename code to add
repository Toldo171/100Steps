https://medium.com/@aprofita_co/14-indie-game-marketing-tips-d8add7c3b5d4
https://webcache.googleusercontent.com/search?q=cache:F5Cje2_xM00J:https://gameanalytics.com/blog/marketing-indie-game-without-budget.html+&cd=18&hl=fr&ct=clnk&gl=fr&client=firefox-b-e
https://gamedevelopment.tutsplus.com/articles/marketing-your-indie-game-the-single-most-important-thing-to-learn--gamedev-7157


//------------------------------------------------------------
//Handles Slime Boss AI (activateSlimeBossAI)
//------------------------------------------------------------
//argument0 = NA

if (alarm[0] == 0)
{
	if (action_count == 0)
	{
		//Every 4 beats, we randomize initial direction and turn
		turn = choose(-1, 1);
		dir_indice = irandom_range(0,3);
		dir = dir_array[dir_indice];
	}
	
	if (action_count == 0 or action_count == 1)
	{
		moveCharacter(dir, self, step_length);
		dir_indice += turn;
		if (dir_indice == -1) {dir_indice = 3;}
		if (dir_indice == 4) {dir_indice = 0;}
		dir = dir_array[dir_indice];
		action_count += 1;
	}
	else if (action_count == 2)
	{
		shoot(directions.down, self, obj_Projectile_Ennemy, x, y + 3 * tile_height);
		shoot(directions.down, self, obj_Projectile_Ennemy, x + 1 * tile_height, y + 3 * tile_height);
		shoot(directions.down, self, obj_Projectile_Ennemy, x + 2 * tile_height, y + 3 * tile_height);
		shoot(directions.down, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 3 * tile_height);
		
		shoot(directions.up, self, obj_Projectile_Ennemy, x, y);
		shoot(directions.up, self, obj_Projectile_Ennemy, x + 1 * tile_height, y);
		shoot(directions.up, self, obj_Projectile_Ennemy, x + 2 * tile_height, y);
		shoot(directions.up, self, obj_Projectile_Ennemy, x + 3 * tile_height, y);
		
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y);
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y + 1 * tile_height);
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y + 2 * tile_height);
		shoot(directions.left, self, obj_Projectile_Ennemy, x, y + 3 * tile_height);
		
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y);
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 1 * tile_height);
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 2 * tile_height);
		shoot(directions.right, self, obj_Projectile_Ennemy, x + 3 * tile_height, y + 3 * tile_height);
		
		action_count += 1;
	}
	else if (action_count == 3)
	{
		action_count = 0;
	}
}

//------------------------------------------------------------
//Check if ennemy is dead (checkDeadEnnemy)
//------------------------------------------------------------
//argument0 = NA

if (currentHearts <= 0)
{
	var x_grid_ennemy = (x div tile_width) * tile_width;
	var y_grid_ennemy = (y div tile_height) * tile_height;
	
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy, y_grid_ennemy, false);
	instance_destroy();
}

//------------------------------------------------------------
//Check if Boss is dead (checkDeadBoss)
//------------------------------------------------------------
//argument0 = NA

if (currentHearts <= 0)
{
	var x_grid_ennemy = (x div tile_width) * tile_width;
	var y_grid_ennemy = (y div tile_height) * tile_height;
	
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy, y_grid_ennemy, true);
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy + tile_width, y_grid_ennemy, true);
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy, y_grid_ennemy + tile_height, true);
	loot(drop_rates_ennemy_keys, drop_rates_ennemy_values, array_size, thresholds, x_grid_ennemy + tile_width, y_grid_ennemy + tile_height, true);
	instance_destroy();
}

//------------------------------------------------------------
//Increase stats according to rune (increaseStats)
//------------------------------------------------------------
//argument0 = Hero

if (slot == "speed")
	{
		if (rune_type == "speed_common")
		{
			var rand = irandom_range(1,3);
		}
		else if (rune_type == "speed_rare")
		{
			var rand = irandom_range(2,5);
		}	
		else if (rune_type == "speed_epic")
		{
			var rand = irandom_range(4,7);
		}	
		else if (rune_type == "speed_legendary")
		{
			var rand = irandom_range(6,10);
		} 
		
	argument0.spd_projectile += rand / 10;
	}
	
	if (slot == "critRate")
	{
		if (rune_type == "critRate_common")
		{
			var rand = irandom_range(1,3);
		}
		else if (rune_type == "critRate_rare")
		{
			var rand = irandom_range(2,5);
		}	
		else if (rune_type == "critRate_epic")
		{
			var rand = irandom_range(4,7);
		}	
		else if (rune_type == "critRate_legendary")
		{
			var rand = irandom_range(6,10);
		} 
	
	//Increase crit rate by x%
	argument0.crit_rate += rand;
	}
	
	if (slot == "critDamage")
	{
		if (rune_type == "critDamage_common")
		{
			var rand = irandom_range(1,3);
		}
		else if (rune_type == "critDamage_rare")
		{
			var rand = irandom_range(2,5);
		}	
		else if (rune_type == "critDamage_epic")
		{
			var rand = irandom_range(4,7);
		}	
		else if (rune_type == "critDamage_legendary")
		{
			var rand = irandom_range(6,10);
		} 
	//Increase crit damage by x%
	argument0.crit_damage += rand / 100;
	}
	
	if (slot == "attack")
	{
		if (rune_type == "attack_common")
		{
			var rand = irandom_range(1,3);
		}
		else if (rune_type == "attack_rare")
		{
			var rand = irandom_range(2,5);
		}	
		else if (rune_type == "attack_epic")
		{
			var rand = irandom_range(4,7);
		}	
		else if (rune_type == "attack_legendary")
		{
			var rand = irandom_range(6,10);
		} 
	
	//Increase attack by x% of base attack	
	argument0.attack += rand / 10;
	}
	
instance_destroy();
